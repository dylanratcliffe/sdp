// Code generated by protoc-gen-go. DO NOT EDIT.
// source: items.proto

package sdp

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	duration "github.com/golang/protobuf/ptypes/duration"
	_struct "github.com/golang/protobuf/ptypes/struct"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// RequestMethod represents the available request methods. The details of these
// methods are:
//
// GET: This takes a single unique query and should only return a single item.
//      If an item matching th paramter passed doesn't exist the server should
//      fail
//
// FIND: This takes no query (or ignores it) and should return all items that it
//       can find
//
// SEARCH: This takes a non-unique query which is designed to be used as a
//         search term. It should return some number of items (or zero) which
//         match the query
type RequestMethod int32

const (
	RequestMethod_GET    RequestMethod = 0
	RequestMethod_FIND   RequestMethod = 1
	RequestMethod_SEARCH RequestMethod = 2
)

var RequestMethod_name = map[int32]string{
	0: "GET",
	1: "FIND",
	2: "SEARCH",
}

var RequestMethod_value = map[string]int32{
	"GET":    0,
	"FIND":   1,
	"SEARCH": 2,
}

func (x RequestMethod) String() string {
	return proto.EnumName(RequestMethod_name, int32(x))
}

func (RequestMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f8bad7296e45e12f, []int{0}
}

// The error type. Any types in here will be gracefully handled unless the
// type os "OTHER"
type ItemRequestError_ErrorType int32

const (
	// NOTFOUND means that the item was not found. This is only returned as the
	// result of a GET request since all other requests would return an empty
	// list instead
	ItemRequestError_NOTFOUND ItemRequestError_ErrorType = 0
	// This should be used of all other failure modes
	ItemRequestError_OTHER ItemRequestError_ErrorType = 1
)

var ItemRequestError_ErrorType_name = map[int32]string{
	0: "NOTFOUND",
	1: "OTHER",
}

var ItemRequestError_ErrorType_value = map[string]int32{
	"NOTFOUND": 0,
	"OTHER":    1,
}

func (x ItemRequestError_ErrorType) String() string {
	return proto.EnumName(ItemRequestError_ErrorType_name, int32(x))
}

func (ItemRequestError_ErrorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f8bad7296e45e12f, []int{1, 0}
}

// ItemRequest represents a request for an item. "type" and "method" are
// required, but "query" is notrequired if the method is FIND since a FIND
// doesn't take parameters
type ItemRequest struct {
	// The type of item to search for
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Which method to use when looking for it
	Method RequestMethod `protobuf:"varint,2,opt,name=method,proto3,enum=RequestMethod" json:"method,omitempty"`
	// What query should be passed to that method
	Query                string   `protobuf:"bytes,3,opt,name=query,proto3" json:"query,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ItemRequest) Reset()         { *m = ItemRequest{} }
func (m *ItemRequest) String() string { return proto.CompactTextString(m) }
func (*ItemRequest) ProtoMessage()    {}
func (*ItemRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f8bad7296e45e12f, []int{0}
}

func (m *ItemRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ItemRequest.Unmarshal(m, b)
}
func (m *ItemRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ItemRequest.Marshal(b, m, deterministic)
}
func (m *ItemRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemRequest.Merge(m, src)
}
func (m *ItemRequest) XXX_Size() int {
	return xxx_messageInfo_ItemRequest.Size(m)
}
func (m *ItemRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ItemRequest proto.InternalMessageInfo

func (m *ItemRequest) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ItemRequest) GetMethod() RequestMethod {
	if m != nil {
		return m.Method
	}
	return RequestMethod_GET
}

func (m *ItemRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

// ItemRequestError is sent back when an item request fails
type ItemRequestError struct {
	Type ItemRequestError_ErrorType `protobuf:"varint,2,opt,name=type,proto3,enum=ItemRequestError_ErrorType" json:"type,omitempty"`
	// The string contents of the error
	Error                string   `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ItemRequestError) Reset()         { *m = ItemRequestError{} }
func (m *ItemRequestError) String() string { return proto.CompactTextString(m) }
func (*ItemRequestError) ProtoMessage()    {}
func (*ItemRequestError) Descriptor() ([]byte, []int) {
	return fileDescriptor_f8bad7296e45e12f, []int{1}
}

func (m *ItemRequestError) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ItemRequestError.Unmarshal(m, b)
}
func (m *ItemRequestError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ItemRequestError.Marshal(b, m, deterministic)
}
func (m *ItemRequestError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemRequestError.Merge(m, src)
}
func (m *ItemRequestError) XXX_Size() int {
	return xxx_messageInfo_ItemRequestError.Size(m)
}
func (m *ItemRequestError) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemRequestError.DiscardUnknown(m)
}

var xxx_messageInfo_ItemRequestError proto.InternalMessageInfo

func (m *ItemRequestError) GetType() ItemRequestError_ErrorType {
	if m != nil {
		return m.Type
	}
	return ItemRequestError_NOTFOUND
}

func (m *ItemRequestError) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// ItemAttributes represents the known attributes for an item. These are likely
// to be common to a given type, but even this is not guaranteed. All items must
// have at least one attribute however as it needs something to uniquely
// identify it
type ItemAttributes struct {
	AttrStruct           *_struct.Struct `protobuf:"bytes,1,opt,name=attrStruct,proto3" json:"attrStruct,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ItemAttributes) Reset()         { *m = ItemAttributes{} }
func (m *ItemAttributes) String() string { return proto.CompactTextString(m) }
func (*ItemAttributes) ProtoMessage()    {}
func (*ItemAttributes) Descriptor() ([]byte, []int) {
	return fileDescriptor_f8bad7296e45e12f, []int{2}
}

func (m *ItemAttributes) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ItemAttributes.Unmarshal(m, b)
}
func (m *ItemAttributes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ItemAttributes.Marshal(b, m, deterministic)
}
func (m *ItemAttributes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemAttributes.Merge(m, src)
}
func (m *ItemAttributes) XXX_Size() int {
	return xxx_messageInfo_ItemAttributes.Size(m)
}
func (m *ItemAttributes) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemAttributes.DiscardUnknown(m)
}

var xxx_messageInfo_ItemAttributes proto.InternalMessageInfo

func (m *ItemAttributes) GetAttrStruct() *_struct.Struct {
	if m != nil {
		return m.AttrStruct
	}
	return nil
}

// This is the same as Item within the package with a couple of exceptions, no
// real reason why this whole thing couldn't be modelled in protobuf though if
// required. Just need to decide what if anything should remain private
type Item struct {
	Type            string          `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	UniqueAttribute string          `protobuf:"bytes,2,opt,name=uniqueAttribute,proto3" json:"uniqueAttribute,omitempty"`
	Attributes      *ItemAttributes `protobuf:"bytes,3,opt,name=attributes,proto3" json:"attributes,omitempty"`
	Metadata        *Metadata       `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Not all items will have relatedItems we are are using a two byte
	// integer to save one byte integers for more common things
	LinkedItemRequests []*ItemRequest `protobuf:"bytes,16,rep,name=linkedItemRequests,proto3" json:"linkedItemRequests,omitempty"`
	// Linked items
	LinkedItems          []*Item  `protobuf:"bytes,17,rep,name=linkedItems,proto3" json:"linkedItems,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Item) Reset()         { *m = Item{} }
func (m *Item) String() string { return proto.CompactTextString(m) }
func (*Item) ProtoMessage()    {}
func (*Item) Descriptor() ([]byte, []int) {
	return fileDescriptor_f8bad7296e45e12f, []int{3}
}

func (m *Item) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Item.Unmarshal(m, b)
}
func (m *Item) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Item.Marshal(b, m, deterministic)
}
func (m *Item) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Item.Merge(m, src)
}
func (m *Item) XXX_Size() int {
	return xxx_messageInfo_Item.Size(m)
}
func (m *Item) XXX_DiscardUnknown() {
	xxx_messageInfo_Item.DiscardUnknown(m)
}

var xxx_messageInfo_Item proto.InternalMessageInfo

func (m *Item) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Item) GetUniqueAttribute() string {
	if m != nil {
		return m.UniqueAttribute
	}
	return ""
}

func (m *Item) GetAttributes() *ItemAttributes {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *Item) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Item) GetLinkedItemRequests() []*ItemRequest {
	if m != nil {
		return m.LinkedItemRequests
	}
	return nil
}

func (m *Item) GetLinkedItems() []*Item {
	if m != nil {
		return m.LinkedItems
	}
	return nil
}

// This is a list of items, like a Find() would return
type Items struct {
	Items                []*Item  `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Items) Reset()         { *m = Items{} }
func (m *Items) String() string { return proto.CompactTextString(m) }
func (*Items) ProtoMessage()    {}
func (*Items) Descriptor() ([]byte, []int) {
	return fileDescriptor_f8bad7296e45e12f, []int{4}
}

func (m *Items) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Items.Unmarshal(m, b)
}
func (m *Items) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Items.Marshal(b, m, deterministic)
}
func (m *Items) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Items.Merge(m, src)
}
func (m *Items) XXX_Size() int {
	return xxx_messageInfo_Items.Size(m)
}
func (m *Items) XXX_DiscardUnknown() {
	xxx_messageInfo_Items.DiscardUnknown(m)
}

var xxx_messageInfo_Items proto.InternalMessageInfo

func (m *Items) GetItems() []*Item {
	if m != nil {
		return m.Items
	}
	return nil
}

// Metadata about the item. Where it came from, how long it took, etc.
type Metadata struct {
	// The context within which the item is unique. Item uniqueness is determined
	// by the combination of type and uniqueAttribue value. However it is possible
	// for the same item to exist in many contexts. There is not formal definition
	// for what a context should be other than the fact that it should be somehwat
	// descriptive and should ensure item uniqueness
	Context string `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	// This is the name of the backend that was used to find the item.
	BackendName   string        `protobuf:"bytes,2,opt,name=backendName,proto3" json:"backendName,omitempty"`
	RequestMethod RequestMethod `protobuf:"varint,3,opt,name=requestMethod,proto3,enum=RequestMethod" json:"requestMethod,omitempty"`
	// The time that the item was found
	Timestamp *timestamp.Timestamp `protobuf:"bytes,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// How long the backend took to execute in total when processing the
	// ItemRequest
	BackendDuration *duration.Duration `protobuf:"bytes,5,opt,name=backendDuration,proto3" json:"backendDuration,omitempty"`
	// How long the backend took to execute per item when processing the
	// ItemRequest
	BackendDurationPerItem *duration.Duration `protobuf:"bytes,6,opt,name=backendDurationPerItem,proto3" json:"backendDurationPerItem,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}           `json:"-"`
	XXX_unrecognized       []byte             `json:"-"`
	XXX_sizecache          int32              `json:"-"`
}

func (m *Metadata) Reset()         { *m = Metadata{} }
func (m *Metadata) String() string { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()    {}
func (*Metadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_f8bad7296e45e12f, []int{5}
}

func (m *Metadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Metadata.Unmarshal(m, b)
}
func (m *Metadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Metadata.Marshal(b, m, deterministic)
}
func (m *Metadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metadata.Merge(m, src)
}
func (m *Metadata) XXX_Size() int {
	return xxx_messageInfo_Metadata.Size(m)
}
func (m *Metadata) XXX_DiscardUnknown() {
	xxx_messageInfo_Metadata.DiscardUnknown(m)
}

var xxx_messageInfo_Metadata proto.InternalMessageInfo

func (m *Metadata) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

func (m *Metadata) GetBackendName() string {
	if m != nil {
		return m.BackendName
	}
	return ""
}

func (m *Metadata) GetRequestMethod() RequestMethod {
	if m != nil {
		return m.RequestMethod
	}
	return RequestMethod_GET
}

func (m *Metadata) GetTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *Metadata) GetBackendDuration() *duration.Duration {
	if m != nil {
		return m.BackendDuration
	}
	return nil
}

func (m *Metadata) GetBackendDurationPerItem() *duration.Duration {
	if m != nil {
		return m.BackendDurationPerItem
	}
	return nil
}

func init() {
	proto.RegisterEnum("RequestMethod", RequestMethod_name, RequestMethod_value)
	proto.RegisterEnum("ItemRequestError_ErrorType", ItemRequestError_ErrorType_name, ItemRequestError_ErrorType_value)
	proto.RegisterType((*ItemRequest)(nil), "ItemRequest")
	proto.RegisterType((*ItemRequestError)(nil), "ItemRequestError")
	proto.RegisterType((*ItemAttributes)(nil), "ItemAttributes")
	proto.RegisterType((*Item)(nil), "Item")
	proto.RegisterType((*Items)(nil), "Items")
	proto.RegisterType((*Metadata)(nil), "Metadata")
}

func init() {
	proto.RegisterFile("items.proto", fileDescriptor_f8bad7296e45e12f)
}

var fileDescriptor_f8bad7296e45e12f = []byte{
	// 526 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x53, 0x4d, 0x6f, 0xd3, 0x40,
	0x10, 0xad, 0x93, 0x38, 0x8d, 0xc7, 0x6d, 0x63, 0x46, 0x15, 0x98, 0x16, 0x41, 0x64, 0x15, 0x88,
	0x38, 0x6c, 0xa4, 0x80, 0x04, 0x07, 0x2e, 0xa5, 0x49, 0x69, 0x0e, 0x4d, 0x60, 0x1b, 0x2e, 0x5c,
	0x90, 0x13, 0x2f, 0xc5, 0x6a, 0x1d, 0x27, 0xeb, 0xb1, 0x44, 0x4e, 0x1c, 0xf8, 0x7f, 0xfc, 0x26,
	0x94, 0xf5, 0x3a, 0x75, 0x9c, 0x22, 0x2e, 0xd6, 0xce, 0x9b, 0xf7, 0xe6, 0xe3, 0x79, 0x17, 0xec,
	0x90, 0x44, 0x94, 0xb0, 0xb9, 0x8c, 0x29, 0x3e, 0x7a, 0x72, 0x1d, 0xc7, 0xd7, 0xb7, 0xa2, 0xa3,
	0xa2, 0x49, 0xfa, 0xbd, 0x93, 0x90, 0x4c, 0xa7, 0xa4, 0xb3, 0xcf, 0xca, 0x59, 0x0a, 0x23, 0x91,
	0x90, 0x1f, 0xcd, 0x35, 0xe1, 0x69, 0x99, 0x10, 0xa4, 0xd2, 0xa7, 0x30, 0x9e, 0x65, 0x79, 0xef,
	0x1b, 0xd8, 0x03, 0x12, 0x11, 0x17, 0x8b, 0x54, 0x24, 0x84, 0x08, 0x35, 0x5a, 0xce, 0x85, 0x6b,
	0xb4, 0x8c, 0xb6, 0xc5, 0xd5, 0x19, 0x5f, 0x40, 0x3d, 0x12, 0xf4, 0x23, 0x0e, 0xdc, 0x4a, 0xcb,
	0x68, 0x1f, 0x74, 0x0f, 0x98, 0x66, 0x5f, 0x2a, 0x94, 0xeb, 0x2c, 0x1e, 0x82, 0xb9, 0x48, 0x85,
	0x5c, 0xba, 0x55, 0x25, 0xce, 0x02, 0xef, 0x17, 0x38, 0x85, 0x06, 0x7d, 0x29, 0x63, 0x89, 0x1d,
	0xdd, 0x25, 0xab, 0x77, 0xcc, 0xca, 0x04, 0xa6, 0xbe, 0xe3, 0xe5, 0x5c, 0xe8, 0x11, 0x0e, 0xc1,
	0x14, 0x2b, 0x28, 0x2f, 0xad, 0x02, 0xef, 0x04, 0xac, 0x35, 0x11, 0xf7, 0xa0, 0x31, 0x1c, 0x8d,
	0xcf, 0x47, 0x5f, 0x86, 0x3d, 0x67, 0x07, 0x2d, 0x30, 0x47, 0xe3, 0x8b, 0x3e, 0x77, 0x0c, 0x6f,
	0x00, 0x07, 0xab, 0xfa, 0xa7, 0x44, 0x32, 0x9c, 0xa4, 0x24, 0x12, 0x7c, 0x0b, 0xe0, 0x13, 0xc9,
	0x2b, 0x65, 0xa4, 0x5a, 0xd5, 0xee, 0x3e, 0x62, 0x99, 0x51, 0x2c, 0x37, 0x8a, 0x65, 0x69, 0x5e,
	0xa0, 0x7a, 0xbf, 0x2b, 0x50, 0x5b, 0xd5, 0xba, 0xd7, 0xa6, 0x36, 0x34, 0xd3, 0x59, 0xb8, 0x48,
	0xc5, 0xba, 0x93, 0xda, 0xcf, 0xe2, 0x65, 0x18, 0x3b, 0x59, 0xff, 0x6c, 0x1a, 0xb5, 0x92, 0xdd,
	0x6d, 0xb2, 0xcd, 0x21, 0x79, 0x81, 0x82, 0xcf, 0xa1, 0x11, 0x09, 0xf2, 0x03, 0x9f, 0x7c, 0xb7,
	0xa6, 0xe8, 0x16, 0xbb, 0xd4, 0x00, 0x5f, 0xa7, 0xf0, 0x3d, 0xe0, 0x6d, 0x38, 0xbb, 0x11, 0x41,
	0xc1, 0xcf, 0xc4, 0x75, 0x5a, 0xd5, 0xb6, 0xdd, 0xdd, 0x2b, 0x9a, 0xcc, 0xef, 0xe1, 0xe1, 0x4b,
	0xb0, 0xef, 0xd0, 0xc4, 0x7d, 0xa0, 0x64, 0x66, 0x26, 0x2b, 0x66, 0xbc, 0x13, 0x30, 0xd5, 0x01,
	0x8f, 0xc1, 0x54, 0x37, 0xd5, 0x35, 0x8a, 0xdc, 0x0c, 0xf3, 0xfe, 0x54, 0xa0, 0x91, 0xcf, 0x88,
	0x2e, 0xec, 0x4e, 0xe3, 0x19, 0x89, 0x9f, 0xa4, 0x2d, 0xcb, 0x43, 0x6c, 0x81, 0x3d, 0xf1, 0xa7,
	0x37, 0x62, 0x16, 0x0c, 0xfd, 0x28, 0x77, 0xac, 0x08, 0xe1, 0x1b, 0xd8, 0x97, 0xc5, 0xfb, 0xa6,
	0x0c, 0xdb, 0xbe, 0x85, 0x9b, 0x24, 0x7c, 0x07, 0xd6, 0xfa, 0x29, 0x68, 0xcf, 0x8e, 0xb6, 0x7e,
	0xf1, 0x38, 0x67, 0xf0, 0x3b, 0x32, 0x9e, 0x41, 0x53, 0xb7, 0xef, 0xe9, 0xa7, 0xe2, 0x9a, 0x4a,
	0xff, 0x78, 0x4b, 0x9f, 0x13, 0x78, 0x59, 0x81, 0x9f, 0xe1, 0x61, 0x09, 0xfa, 0x24, 0xe4, 0xca,
	0x1e, 0xb7, 0xfe, 0xbf, 0x5a, 0xff, 0x10, 0xbe, 0x62, 0xb0, 0xbf, 0xb1, 0x31, 0xee, 0x42, 0xf5,
	0x63, 0x7f, 0xec, 0xec, 0x60, 0x03, 0x6a, 0xe7, 0x83, 0x61, 0xcf, 0x31, 0x10, 0xa0, 0x7e, 0xd5,
	0x3f, 0xe5, 0x67, 0x17, 0x4e, 0xe5, 0x83, 0xf9, 0xb5, 0x9a, 0x04, 0xf3, 0x49, 0x5d, 0x75, 0x78,
	0xfd, 0x37, 0x00, 0x00, 0xff, 0xff, 0x1f, 0x33, 0x6d, 0x92, 0x55, 0x04, 0x00, 0x00,
}
