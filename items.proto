syntax = "proto3";

import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";

option go_package = "protocol";

// RequestMethod represents the available request methods
enum RequestMethod {
  GET = 0;
  FIND = 1;
  SEARCH = 2;
}

// ItemRequest represents a request for an item from the coordinator. This is a
// non-blocking request and the item will either be returned within the
// currently open stream, or an error will be sent to the
// ItemRequestErrors rpc
message ItemRequest {
  // The type of item to search for
  string type = 1;
  RequestMethod method = 2;

  // What query should be passed to that method
  string query = 3;
}

// ItemRequestError is sent back when an item request fails
message ItemRequestError {
  // The error type. Any types in here will be gracefully handled unless the
  // type os "OTHER"
  enum ErrorType {
    NOTFOUND = 0;
    OTHER = 1;
  }
  ErrorType type = 2;

  // The string contents of the error
  string error = 3;
}

message ItemAttributes {
  google.protobuf.Struct attrStruct = 1;
}

// Metadata about the item. Where it came from, how long it took, etc.
message Metadata {
  string context = 1;
  string backendName = 2;

  RequestMethod requestMethod = 3;

  google.protobuf.Timestamp timestamp = 4;
  google.protobuf.Duration backendDuration = 5;
  google.protobuf.Duration backendDurationPerItem = 6;
}

// This is the same as Item within the package with a couple of exceptions, no
// real reason why this whole thing couldn't be modelled in protobuf though if
// required. Just need to decide what if anything should remain private
message Item {
  string type = 1;
  string uniqueAttribute = 2;
  ItemAttributes attributes = 3;
  Metadata metadata = 4;

  // --- Optional ---

  // Not all items will have relatedItems we are are using a two byte
  // integer to save one byte integers for more common things
  repeated ItemRequest linkedItemRequests = 16;

  // Linked items
  repeated Item linkedItems = 17;

  // If an item needs to return a socket it will do the following:
  //
  // 1. Call the sockert RPC on the server with the socketID as metadata
  // 2. Respond with the item and include a socket ID. This should by a UUID
  //    represented as a string of 128 bytes
  //
  // bytes socketID = 18;

  // TODO: Do I need the ID field? Or will this be regenerated? (For graphs)
}

// This is a list of items, like a Find() would return
message Items {
  repeated Item items = 1;
}
